
Project 4 -- Decoding a Huffman-coded message

    Due Nov 5 by 11pm Points 75 Submitting a text entry box

Project: Huffman Decoder — Reconstructing the Original Message

 
Introduction

In the previous project, you implemented a Huffman encoder — a program that reads a text file, analyzes word frequencies, builds a Huffman tree, and encodes the text into a compact binary-like form.

Your encoder took a raw text file and produced three main outputs:

    A .tokens file — the list of words (tokens) extracted from the text.
    A .freq file -- the list of words and their frequencies after being ordered by the priority queue.

    A .hdr (header) file — describing the Huffman tree structure, so the same codes can be reconstructed later.

    A .code file — the encoded representation of the text, written using Huffman codes derived from word frequencies.

 

You can think of this as a miniature version of how data compression works in real systems. When you send compressed information (for example, a zipped file, an image, or a text message) across a network, you rarely send the original data — you send a compact code plus the information needed to decode it. That is, you send the .code and the .hdr files over the network.

On the receiving end of the network, you have access to the encoded message and its header, but not the original text file or even the Huffman tree that was used to compress it.

Your task is to reconstruct the original message — word for word — using only the .hdr and .code files. This is your Huffman Decoder.

 
The Goal

The goal is to write a program that reads a Huffman header (.hdr) and code file (.code) and reconstructs the original sequence of words.

The output should be identical to the .tokens file produced during the encoding phase.

If the encoding process can be thought of as “compress and send,” this project represents “receive and decompress.”

 

 
The Big Picture: From Compression to Decompression

Let’s recall how the encoder worked step by step:

Step
	

Encoder Task
	

Output

1
	

Tokenize the input text into words
	

.tokens file

2
	

Build a BST to count word frequencies
	

Vector of (word, freq) pairs

3
	

Use a PriorityQueue to build the Huffman tree
	

Huffman tree

4
	

Generate codes for each word using tree traversal
	

.hdr and .code files

 

Your decoder will reverse this process:

 

Step
	

Decoder Task
	

Input
	

Output

1
	

Reconstruct the Huffman tree from the header file
	

.hdr
	

Internal Huffman tree

2
	

Read the encoded sequence from the code file
	

.code
	

Series of 0s and 1s

3
	

Traverse the Huffman tree according to those bits to find words
	

.hdr, .code
	

a .tokens_decoded file

 

 
The Header File (.hdr)

Your header file was produced by performing a preorder traversal of the Huffman tree. During that traversal, each leaf node (each word) was written to the header as a line containing the word followed by its Huffman code, separated by a space:

car  010
engine  111
road  10

This format contains the essential information about the Huffman tree — the mapping from each word to its corresponding binary code. Because the traversal algorithm to generate the header visits every leaf once, the header file contains one line per word in the original text.

When decoding, your program will read this file line by line, rebuild the tree structure, and reestablish the same code–word relationships that existed during encoding.

    Start with an empty root node.

    For each (word, code) pair:

        Begin at the root.

        For each bit in the code:

            If the bit is 0, go to (or create) the left child.

            If the bit is 1, go to (or create) the right child.

         

        When you reach the end of the code, assign the word to that node (it’s a leaf).

     

After reading all entries, you’ll have exactly the same Huffman tree that your encoder used to generate the codes.

That tree can then be used to decode the .code file bit by bit.

 
Using the Code File (.code)

The code file contains the actual encoded message: a long sequence of 0s and 1s representing the words of the original text, written using the Huffman codes defined in the header. As the decoder reads each bit, it traverses the Huffman tree, from the root to a leaf node, by repeatedly applying the following steps.

    0 → move to the left child

    1 → move to the right child

    When it reaches a leaf node, it outputs the corresponding word, then returns to the root and continues. This process repeats until all bits have been consumed.

 
Input/output

Input:

Names of the header and code files, in that order. Recall that the code file contains new-line characters.

 

Output:

A file whose name uses the base name of the input files with the extension .tokens_decoded.

 

Example (runs in the project directory)

$ ./huff_decode.x article.hdr article.code

Generates 

article.tokens_decoded

After decoding, you can verify your output by comparing it to the original .tokens file:

$ diff article.tokens_decoded articles.tokens

If the output is empty, your decoder is correct.

Just as in the original Huffman tree project, all input and output files reside in the directory input_file, which in turn is located inside your project directory.

 
Error Handling and Validation

Your program should check for potential errors in both usage and file contents:

 

    Ensure that there are exactly two command-line arguments.

    Verify that both input arguments are readable files.

    Confirm that the output file can be created and opened for writing.

    Perform simple sanity checks on file contents:

     

        The header file should start with a letter (not 0 or 1).

        The code file should start with a 0 or 1.

        These checks are intentionally simple and primarily serve as early validation.

     

    If the code file ends while traversal is still at an internal node of the Huffman tree (i.e., before reaching a valid leaf), print an appropriate error message and exit gracefully.

 
Implementation Notes

You have already implemented a HuffmanTree class for encoding. The decoder uses many of the same ideas but in reverse. While the interface may differ slightly, your overall design should mirror the organization and clarity of your encoding project.

To help you stay consistent and avoid unnecessary complexity, please follow these structural guidelines.

 
1. The main Function

Keep your main() simple and focused on setup and orchestration. Its responsibilities are:

    Make sure the input files exist and the output file can be written.
    Use a function to read the header file (.hdr) line by line and store the pairs in a std::vector<std::pair<std::string, std::string>>.
    Construct an instance of the decoder Huffman tree using this vector. For example:

      // perform initial error checking...
      std::vector<std::pair<std::string, std::string>> header_pairs;
      // readHeader is a function defined in main.cpp
      auto header_status = readHeader(name_of_input_file, header); 
      // perform error checking...
      HuffmanTree decoder();
      auto build_status = decoder.buildFromHeader(header_pairs);
      // ...
      // open the input .code file (call it code_stream) and .tokens_decoded files (out_stream)
      atuo decode_status = decoder.decode(code_stream, out_stream)
      // ...

 

A few notes...       

You may encounter errors while building the tree. For that reason, avoid constructing it directly inside the class constructor.
Instead, provide a separate function (buildFromHeader) that can validate the input and report any problems before returning a complete tree.

The decode() function of HuffmanTree should read the encoded file one character at a time, process it incrementally, and write the decoded output as it goes. This approach is memory-efficient because it does not store the entire encoded message in memory. It also mirrors the behavior of the encoder: encoding was performed progressively, writing each code as it was generated. Decoding should follow the same principle — read and write one message unit at a time. 

The code file, in addition to zeros and ones, has new-line characters. You need to identify and discard them as you decode the message.

 